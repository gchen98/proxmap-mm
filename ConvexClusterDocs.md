# Introduction #

I have only tested on a Linux platform but there is no reason this C++ program should not run on Mac or Windows with proper adjustments to the makefile. Please contact me if you run into issues on Linux or other platforms.

# Compile #

Please follow the general instructions found in Intro. We also included some utility functions for generating the k nearest neighbor weight file, so if you need to compile these, this can be done with commands **make distance** and **make knn\_weights** from the **src/convex\_clustering** directory.
```
[garyc@ssb202q-1 trunk]$ cd src/convex_clustering/
[garyc@ssb202q-1 convex_clustering]$ make distance
mpic++ -o ../../bin/distance   -DUSE_MPI distance.cpp
[garyc@ssb202q-1 convex_clustering]$ make knn_weights 
mpic++ -o ../../bin/knn_weights   -DUSE_MPI knn_weights.cpp
```

# Running examples #

This section should get you up and running quickly, using Fisher's famous Iris data set, downloaded from the UCI machine learning repository. Enter the **examples/convex\_clustering** directory.
```
[garyc@ssb202q-1 trunk]$ cd examples/convex_clustering/
[garyc@ssb202q-1 convex_clustering]$ ls
convexcluster  iris	    plot_path.r  README.txt
distance       knn_weights  plot.sh	 run.sh
```

Running _convexcluster_ simply entails executing **./run.sh**.
```
[garyc@ssb202q-1 convex_clustering]$ ./run.sh 
...
(console messages will appear that allow you to monitor the progress of the optimization)
...
```

We also include a plotting utility to conveniently view the cluster results on the first two principal components of the data. You will need **R** and the R libary **ggplot2** in order for this script to run. Execute **./plot.sh** to run the script, and open **iris\_projection.pdf** in your favorite PDF viewer. You should be able to see the cluster path depicted as:

![https://proxmap-mm.googlecode.com/svn/trunk/examples/convex_clustering/iris_projection.png](https://proxmap-mm.googlecode.com/svn/trunk/examples/convex_clustering/iris_projection.png)

# Running _convexcluster_ on your own dataset #

Using your favorite editor, you will only need to change a few properties in the **run.sh** and **plot.sh** scripts. Instructions for setting these values are prefixed with a # comment symbol, and are located in the section # configure these settings as appropriate.

In particular, for the **run.sh** script, you can specify the **k** nearest neighbors and soft-thresholding parameter **phi** that are used for defining pairwise weights between data points.

If you need to use binaries that you compiled yourself, you can uncomment the line under **# uncomment below for dynamically linked binaries**, but comment the line under **# uncomment below for statically linked binaries**.  Alternatively, you can simply copy the contents of ../../bin into your current directory.

Specify the name of the directory that your project files (which include the input data file, and any generated plots) will reside in. For the iris data, we defaulted this to **iris**.

The property **configtemplate** specifies the name of the configuration file that is found in the project directory. Please read the next section if you wish to customize this further.

The **datafile** and **weightfile** properties specify the name of the data matrix input file, and the weights file that will be generated internally by the **run.sh** script.

Plotting results is fairly straightforward. You can open **plot.sh** with your favorite editor, and edit the four properties (the first two are already explained in the notes above). The **labelfile** property points to a single column file that contains the labels that will annotated the plot. The order of the labels must match the order of the data points in the data matrix. The **pdffile** property specifies the name of the PDF file that will be generated by R.

# Customizing _convexcluster_ (optional) #

_convexcluster_ reads in input parameters from a configuration file (in our example, it is iris/config.template) consisting of key value pairs. Our provided shell scripts automatically fill in the properties containing all caps in the value. The program requires only a handful of input parameters to run. There are also several optional tuning parameters, but they are set to reasonable defaults internally, and overridden only when they are present in the configuration file.
The following are required parameters:

  * USE\_CPU: set this to 1 in general to run on the CPU
  * USE\_GPU: set this to 1 in general to run on the GPU (note that you can run on both devices but this is obviously not ideal for performance if you already have a GPU).

If you have a GPU the following parameters are required:

  * PLATFORM\_ID: OpenCL can query the number of platforms on your machine. Platforms include CPU or GPU usually. Running the **CLInfo** utility from the OpenCL SDK will give you the platform ID, which is an integer starting from 0.
  * DEVICE\_ID: OpenCL can query the number of devices on your machine for a specific platform. Running the **CLInfo** utility from the OpenCL SDK will give you the device ID listed under each platform, given as an integer starting from 0.
  * KERNELS: Specify the full path of your installation, appended with the string **src/convex\_clustering/kernels/**.  For example: **/home/garyc/proxmap-mm-read-only/src/convex\_clustering/kernels/**

Some optional parameters:

  * PRINT\_THRESHOLD: Sometimes you may not want to write to disk the matrix of cluster centers at every point on the regularization path. When this parameter is set to zero, every matrix is printed out. For higher values, a write is performed only when the norm of the difference between the previous matrix and the current matrix exceeds this threshold.
  * MAX\_ITER: The maximum number of iterations to carry out when minimizing the objective function at a particular value of the regularization parameter mu.
  * OUTPUT\_PATH: Make a directory first that will store the sequence of files that store the cluster centers.  Specify the path of this directory here.
  * OBJ\_EPSILON: Specify the tolerance for convergence here. If we are less than MAX\_ITER and the previous objective minus the current objective is less than this value, we have declared convergence.
  * MU\_MIN: The smallest non-zero value of the regularization parameter to begin the path from.
  * MU\_INCREMENT: The value to increment mu by.